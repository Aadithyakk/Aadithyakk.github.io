[{"content":"In machine learning, dataset splitting is an essential step to evaluate model performance. Traditionally, random splitting is widely used — especially with tools like scikit-learn where you can just set a random seed to ensure reproducibility. However, there\u0026rsquo;s another method that provides even more control and consistency: the hash and modulo split method.\nIn this post, we’ll dive into the details of how this method works, why it can be useful compared to traditional random splitting with a fixed seed, and explore scenarios where it can shine.\nThe Traditional Approach: Random Splitting with a Seed Most machine learning practitioners are familiar with random splitting, where you randomly divide your data into training and testing sets (or training, validation, and testing sets). Tools like scikit-learn make this easy. You can simply use the train_test_split() function and provide a random seed for reproducibility:\n1 2 3 4 from sklearn.model_selection import train_test_split # Example of using train_test_split with a random seed X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) By specifying random_state=42, you ensure that every time the code is run, the same split is produced. This allows for reproducible results, which is critical when you want to debug models or share results with others.\nIssues with Random Seed-Based Splitting While setting a random seed provides a level of consistency, it still has some drawbacks:\nRequires Storage of the Seed:\nIf the seed is not stored or is lost, the split can no longer be reproduced exactly. This can happen when working across different teams or machines. Even with a seed, future experiments may need an entirely new split.\nPotential for Data Leakage:\nRandom splitting could inadvertently lead to data leakage when data from the same user, session, or time period appears in both the training and testing sets. This is particularly problematic in scenarios where there’s a temporal or user-related structure in the data.\nDifferent Splits for Different Versions of the Data:\nIf your data changes frequently (e.g., new users being added), the random seed will generate a different split every time the dataset is updated. This can make comparisons between different iterations of a model challenging.\nThis is where the hash and modulo split method can come into play.\nWhat is the Hash and Modulo Split Method? The hash and modulo split method provides a deterministic way to split a dataset based on a unique identifier for each data point. This method is especially useful for datasets with inherent structures, such as user-based data, session-based data, or any scenario where reproducibility without randomness is desired.\nStep-by-Step Explanation Choose a Unique Identifier:\nEach data point in your dataset must have a unique identifier. This could be a user ID, session ID, or row index, depending on your dataset. The uniqueness is essential to ensure that the same data point will always be hashed to the same value.\nHash the Identifier:\nA hash function, such as SHA-256, is applied to the unique identifier. The hash function converts the identifier into a fixed-size string or integer. Importantly, hash functions are deterministic, meaning that the same input will always produce the same output.\nApply Modulo Operation:\nOnce the identifier has been hashed, the result is passed through a modulo operation. The modulo operation divides the hash value by a number (say, N) and returns the remainder. This remainder is used to assign the data point to either the training or testing set. For example, if you want an 80/20 split, you could use hash(id) % 5 — data points where the remainder is 0 go to the test set (20%), while all others go to the training set (80%).\nExample Implementation Here’s an example of how this method can be implemented in Python using the hashlib library:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import hashlib # Function to hash a unique identifier and split based on modulo def hash_and_modulo_split(unique_id, split_ratio=0.2): # Create a SHA-256 hash of the identifier (e.g., user ID) hash_value = int(hashlib.sha256(str(unique_id).encode()).hexdigest(), 16) # Apply modulo operation to split (e.g., 80/20 split using modulo 5) if hash_value % 5 == 0: return \u0026#39;test\u0026#39; # 20% chance else: return \u0026#39;train\u0026#39; # 80% chance # Example usage for a list of unique IDs data_point_ids = [101, 102, 103, 104, 105] splits = [hash_and_modulo_split(dp_id) for dp_id in data_point_ids] print(splits) This approach ensures that every time you run the code, the split is consistent, as the hash of each identifier will always yield the same result.\nWhy Prefer Hash and Modulo Over Random Seeds? While random seed-based splitting is convenient and effective, there are certain cases where the hash and modulo method offers significant advantages.\n1. Perfect Reproducibility Across Data Changes When using random splitting, if the data changes (e.g., new rows are added), the split could change even with the same seed. This can lead to inconsistent model evaluations and comparisons. With hash and modulo splitting, new data points will always get assigned based on their unique identifier, meaning the old data points will continue to fall into the same training or testing set, while only the new ones will be assigned accordingly.\n2. Prevention of Data Leakage In cases like time-series data, or data where certain rows are related (e.g., the same user appears multiple times), random splitting can lead to data leakage — where information in the training set is indirectly used in the test set. Hash and modulo methods can prevent this. For example, by hashing a user ID, all data for a single user will be consistently placed in either the training or testing set, ensuring there\u0026rsquo;s no overlap.\n3. Scalability For very large datasets distributed across different systems, it’s difficult to maintain a shared random seed and state to ensure consistent splitting. Hash and modulo methods, on the other hand, are stateless — they don’t require knowledge of the entire dataset. You can compute splits independently on different machines as long as you have access to the unique identifier and hashing method. This makes the approach scalable across distributed environments.\n4. No Need for Seed Management One of the headaches with random splitting is managing the seed. If you accidentally change or lose the seed, reproducibility is lost. Hash and modulo methods don’t require any seeds, as the split is purely based on the unique identifier of the data points, making it inherently reproducible and reducing operational complexity.\n5. Control Over Split Proportions With random seed-based methods, ensuring a perfectly balanced 80/20 split can sometimes be tricky, especially when your dataset size isn’t evenly divisible by 5. The hash and modulo method, however, guarantees that you can split exactly 80% of the data for training and 20% for testing (or any other ratio you choose).\nWhen to Use Random Splitting That said, the hash and modulo split method isn’t always the best choice. In scenarios where:\nClass Balancing is important: If you need a balanced distribution of classes between the training and test sets (especially in small datasets), random splitting can ensure better distribution.\nSmall Datasets: For small datasets, randomness can be beneficial as it introduces more diversity in both the training and test sets.\nConclusion The hash and modulo split method is a powerful and deterministic alternative to random seed-based splitting, offering perfect reproducibility, prevention of data leakage, and scalability. If your dataset is large, structured, or if reproducibility is critical in the face of changing data, this method is worth considering.\nWhile random seed-based methods are still the go-to for many, the hash and modulo split method ensures that your model is trained and tested consistently, across different runs and data versions, without the need to manage seeds or worry about accidental data leakage.\n","date":"2024-09-15T00:00:00Z","image":"https://aadithyakk.github.io/p/hash-and-modulo-split-method/sha-256_hu12647158158414139947.jpg","permalink":"https://aadithyakk.github.io/p/hash-and-modulo-split-method/","title":"Hash and Modulo Split Method: A Deterministic Alternative to Random Splits"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://aadithyakk.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://aadithyakk.github.io/p/image-gallery/2_hu15576070775610481867.jpg","permalink":"https://aadithyakk.github.io/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://aadithyakk.github.io/p/shortcodes/cover_hu17063188895770243625.jpg","permalink":"https://aadithyakk.github.io/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://aadithyakk.github.io/p/math-typesetting/","title":"Math Typesetting"}]